--1. create table--
create table tableP
(
  col1 int primary key,
  col2 nvarchar2(100)
);

--2. insert into table1--
insert into tableP(col1, col2) values (1, 'str1');
insert into tableP(col1, col2) values (2, 'str2');
insert into tableP(col1, col2) values (3, 'str3');
insert into tableP(col1, col2) values (4, 'str4');
insert into tableP(col1, col2) values (5, 'str5');
insert into tableP(col1, col2) values (6, 'str6');
insert into tableP(col1, col2) values (7, 'str7');
insert into tableP(col1, col2) values (8, 'str8');
insert into tableP(col1, col2) values (9, 'str9');
insert into tableP(col1, col2) values (10, 'str10');

select * from tableP;


--3. before trigger for insert, delete, update--
create or replace trigger tableP_before_trigger
  before insert or update or delete on tableP
begin
  if inserting
    then dbms_output.put_line('tableP_before_trigger_insert');
  elsif updating
    then dbms_output.put_line('tableP_before_trigger_update');
  elsif deleting
    then dbms_output.put_line('tableP_before_trigger_delete');
  end if;
end;

--4. before trigger for insert, delete, update for each row--
create or replace trigger tableP_before_trigger_row
  before insert or update or delete on tableP
  for each row
begin
  if inserting
    then dbms_output.put_line('tableP_before_trigger_row_insert');
  elsif updating
    then dbms_output.put_line('tableP_before_trigger_row_update');
  elsif deleting
    then dbms_output.put_line('tableP_before_trigger_row_delete');
  end if;
end;

--5. use before triggers--
delete tableP where col1 = 1;
insert into tableP(col1, col2) values (100, 'str1');
update tableP set col1 = 1 where col1 = 100;

--6. after trigger for insert, delete, update--
create or replace trigger tableP_after_trigger
  after insert or update or delete on tableP
begin
  if inserting
    then dbms_output.put_line('tableP_after_trigger_insert');
  elsif updating
    then dbms_output.put_line('tableP_after_trigger_update');
  elsif deleting
    then dbms_output.put_line('tableP_after_trigger_delete');
  end if;
end;

--7. after trigger for insert, delete, update for each row--
create or replace trigger tableP_after_trigger_row
  after insert or update or delete on tableP
  for each row
begin
  if inserting
    then dbms_output.put_line('tableP_after_trigger_row_insert');
  elsif updating
    then dbms_output.put_line('tableP_after_trigger_row_update');
  elsif deleting
    then dbms_output.put_line('tableP_after_trigger_row_delete');
  end if;
end;

--use after triggers--
delete tableP where col1 = 1;
insert into tableP(col1, col2) values (100, 'str1');
update tableP set col1 = 1 where col1 = 100;

--8. create table audit--
create table auditTable
(
  id int generated by default as identity,
  OperationDate timestamp default(sysdate),
  OperationType nvarchar2(100),
  TriggerName nvarchar2(100),
  Data nvarchar2(100),
  primary key(id)
);

--9. log all operations in audit table via triggers--
create or replace trigger tableP_before_trigger
  before insert or update or delete on tableP
begin
  if inserting
    then dbms_output.put_line('tableP_before_trigger_insert');
    insert into auditTable(OperationType, TriggerName, Data)
      values ('INSERT', 'tableP_before_trigger', 'insert rows');
  elsif updating
    then dbms_output.put_line('tableP_before_trigger_update');
    insert into auditTable(OperationType, TriggerName, Data)
      values ('UPDATE', 'tableP_before_trigger', 'update rows');
  elsif deleting
    then dbms_output.put_line('tableP_before_trigger_delete');
    insert into auditTable(OperationType, TriggerName, Data)
      values ('DELETE', 'tableP_before_trigger', 'delete rows');
  end if;
end;

create or replace trigger tableP_before_trigger_row
  before insert or update or delete on tableP
  for each row
begin
  if inserting
    then dbms_output.put_line('tableP_before_trigger_row_insert');
    insert into auditTable(OperationType, TriggerName, Data)
      values ('INSERT', 'tableP_before_trigger_row', 'old: ' || :old.col1 || ' ' || :old.col2 ||
              ' - new: ' || :new.col1 || ' ' || :new.col2);
  elsif updating
    then dbms_output.put_line('tableP_before_trigger_row_update');
    insert into auditTable(OperationType, TriggerName, Data)
      values ('UPDATE', 'tableP_before_trigger_row', 'old: ' || :old.col1 || ' ' || :old.col2 ||
              ' - new: ' || :new.col1 || ' ' || :new.col2);
  elsif deleting
    then dbms_output.put_line('tableP_before_trigger_row_delete');
    insert into auditTable(OperationType, TriggerName, Data)
      values ('DELETE', 'tableP_before_trigger_row', 'old: ' || :old.col1 || ' ' || :old.col2 ||
              ' - new: ' || :new.col1 || ' ' || :new.col2);
  end if;
end;

create or replace trigger tableP_after_trigger
  after insert or update or delete on tableP
begin
  if inserting
    then dbms_output.put_line('tableP_after_trigger_insert');
    insert into auditTable(OperationType, TriggerName, Data)
      values ('INSERT', 'tableP_after_trigger', 'insert rows');
  elsif updating
    then dbms_output.put_line('tableP_after_trigger_update');
    insert into auditTable(OperationType, TriggerName, Data)
      values ('UPDATE', 'tableP_after_trigger', 'update rows');
  elsif deleting
    then dbms_output.put_line('tableP_after_trigger_delete');
    insert into auditTable(OperationType, TriggerName, Data)
      values ('DELETE', 'tableP_after_trigger', 'delete rows');
  end if;
end;

create or replace trigger tableP_after_trigger_row
  after insert or update or delete on tableP
  for each row
begin
  if inserting
    then dbms_output.put_line('tableP_after_trigger_row_insert');
    insert into auditTable(OperationType, TriggerName, Data)
      values ('INSERT', 'tableP_after_trigger_row', 'old: ' || :old.col1 || ' ' || :old.col2 ||
              ' - new: ' || :new.col1 || ' ' || :new.col2);
  elsif updating
    then dbms_output.put_line('tableP_after_trigger_row_update');
    insert into auditTable(OperationType, TriggerName, Data)
      values ('UPDATE', 'tableP_after_trigger_row', 'old: ' || :old.col1 || ' ' || :old.col2 ||
              ' - new: ' || :new.col1 || ' ' || :new.col2);
  elsif deleting
    then dbms_output.put_line('tableP_after_trigger_row_delete');
    insert into auditTable(OperationType, TriggerName, Data)
      values ('DELETE', 'tableP_after_trigger_row', 'old: ' || :old.col1 || ' ' || :old.col2 ||
              ' - new: ' || :new.col1 || ' ' || :new.col2);
  end if;
end;

delete tableP where col1 = 1;
insert into tableP(col1, col2) values (100, 'str1');
update tableP set col1 = 1 where col1 = 100;

select * from auditTable;

--10. integrity violation operation--
insert into tableP(col1, col2) values (10, 'str10');
select * from auditTable;

commit;

--11. drop tableP--
drop table tableP;
rollback;
select * from tableP;
select * from auditTable;

--create trigger that forbid table drop--
create or replace trigger tableP_forbid_drop_trigger
  before drop on schema
begin
  if (upper(trim(ora_dict_obj_name)) = 'TABLEP' 
      or upper(trim(ora_dict_obj_name)) = 'AUDITTABLE')
    then dbms_output.put_line('table_forbid_drop_trigger');
    raise_application_error(-20001, 'drop forbidden');
  end if;
end;

drop table tableP;

--12. drop auditTable--
drop table auditTable;

--13. create view for tableP--
create view view_tableP
as select col1, col2 from tableP;

select * from view_tableP;
insert into view_tableP(col1, col2) values(11, 'str11');

--instead of trigger--
create or replace trigger tableP_insteadof_trigger_ins
  instead of insert on view_tableP
for each row
begin
  dbms_output.put_line('tableP_insteadof_trigger_insert');
  insert into tableP(col1, col2) values(:new.col1, :new.col2);
end;

delete tableP where col1 = 11 and col1 = 12;
insert into view_tableP(col1, col2) values(12, 'str12');